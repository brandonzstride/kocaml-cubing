(*
  All `failwith` calls in the file should be logically impossible
  if the code is correct.   
*)

(*
  IMPORTANT NOTE:
    I currently dont' use the reflection symmetry because it will involve
    a significant change in how I represent moves.

    All the code is commented out and kept in place for the reflection.
    I make a special note for code that is added or changed to accomodate
    the removal of the reflection.
*)


open Core

module Generator =
  struct
    (*
      These symmetries generate all possible cube symmetries that
      preserve the UD slice.
      
      S_F2  : 180 degree turn around axis through F and B faces. Order 2.
      S_U4  : 90 degree clockwise turn around axis through U and D faces. Order 4.
      S_LR2 : reflection across the plane between the L and R faces. Order 2.
    *)
    type t = S_F2 | S_U4 (* | S_LR2 *) (* Spot-fix: remove the reflection *)

    let to_move : t -> Move.t =
    let open Cubie in
    let open Cubie.Edge in
    let open Cubie.Corner in
    let open Modular_int in
    function
    | S_F2 -> begin function
      | Edge e ->
        let e' = begin match e with
        | UR -> DL | UF -> DF | UL -> DR | UB -> DB
        | DR -> UL | DF -> UF | DL -> UR | DB -> UB
        | FR -> FL | FL -> FR | BL -> BR | BR -> BL end
        in With_orientation.Edge { e = e' ; o = Z2.zero }
      | Corner c ->
        let c' = begin match c with
        | URF -> DLF | UFL -> DFR | ULB -> DRB | UBR -> DBL
        | DFR -> UFL | DLF -> URF | DBL -> UBR | DRB -> ULB end
        in With_orientation.Corner { c = c' ; o = Z3.zero }
      end
    | S_U4 -> begin function
      | Edge e ->
        let e', o = begin match e with
        | UR -> UB, 0 | UF -> UR, 0 | UL -> UF, 0 | UB -> UL, 0
        | DR -> DB, 0 | DF -> DR, 0 | DL -> DF, 0 | DB -> DL, 0
        | FR -> BR, 1 | FL -> FR, 1 | BL -> FL, 1 | BR -> BL, 1 end
        in With_orientation.Edge { e = e' ; o = Z2.of_int o }
      | Corner c ->
        let c' = begin match c with
        | URF -> UBR | UFL -> URF | ULB -> UFL | UBR -> ULB
        | DFR -> DRB | DLF -> DFR | DBL -> DLF | DRB -> DBL end
        in With_orientation.Corner { c = c' ; o = Z3.zero }
      end
    (* | S_LR2 -> begin function
      | Edge e ->
        let e' = begin match e with
        | UR -> UL | UL -> UR | FR -> FL | FL -> FR
        | BR -> BL | BL -> BR | DR -> DL | DL -> DR | _ -> e end
        in With_orientation.Edge { e = e' ; o = Z2.zero }
      | Corner c -> 
        let c' = begin match c with
        | URF -> UFL | UFL -> URF | UBR -> ULB | ULB -> UBR
        | DFR -> DLF | DLF -> DFR | DBL -> DRB | DRB -> DBL end
        in With_orientation.Corner { c = c' ; o = Z3.zero }  *)
        (* S_LR2 should apply additive inverse to orientation if corner orientations matter *)
        (* TODO: come up with a type so that symmetries can work for corner orientation coordinates *)
      (* end *)
  end

module Multiples =
  struct
    (*
      Some power of a generator. counts are constrained by module S below.   
    *)
    type t = { gen : Generator.t ; count : int }

    (* must be careful on S_LR2 because it's currently wrong *)
    let to_move =
      let open Generator in
      let open Move in
      let aux gen =
        let m = Generator.to_move gen in
        function
        | 0 -> Move.id
        | 1 -> m 
        | 2 -> m * m
        | _ -> m * m * m (* logically must be 3 by pattern match below *)
      in
    function
    | { gen = S_F2  ; count } when count < 2 -> aux S_F2  count
    | { gen = S_U4  ; count } when count < 4 -> aux S_U4  count
    (* | { gen = S_LR2 ; count } when count < 2 -> aux S_LR2 count *)
    | _ -> failwith "bad symmetry multiple"
  end

module S =
  struct
    (* s = 8x_2 + 2x_3 + x_4 *)
    (* m = S_F2^x_2 * S_U4^x_3 * S_LR2^x_4 *)
    (*
      A symmetry is some element in the group generated by the
      Generator class above. We can constrain the exponents on the 
      generators to only their group order so that we don't get deeply
      nested functions when converting to Move.t.
    *)
    type t =
      { x_2 : Modular_int.Z2.t
      ; x_3 : Modular_int.Z4.t
      (*; x_4 : Modular_int.Z2.t *) } [@@deriving enumerate]

    let to_rank { x_2 ; x_3 (*; x_4 *) } =
      let open Modular_int in
      (* Z2.to_int x_2 * 8 + Z4.to_int x_3 * 2 + Z2.to_int x_4 *)
      (* The original code above is changed to the below to not consider the final term *)
      Z2.to_int x_2 * 4 + Z4.to_int x_3
    
    let n = List.length all (* should be 16 (8 with no reflection) *)

    let of_rank x =
      let open Modular_int in
      (* { x_2 = Z2.of_int (x / 8)
      ; x_3 = Z4.of_int ((x mod 8) / 2)
      ; x_4 = Z2.of_int x } *)
      (* The original code above is changed to the below to not consider the final term *)
      { x_2 = Z2.of_int (x / 4)
      ; x_3 = Z4.of_int (x mod 4) }
    
    (* must be careful on S_LR2 *)
    let to_move (s : t) : Move.t =
      let open Move in
      Multiples.(
          to_move { gen = S_F2  ; count = Modular_int.Z2.to_int s.x_2 }
        * to_move { gen = S_U4  ; count = Modular_int.Z4.to_int s.x_3 }
        (* * to_move { gen = S_LR2 ; count = Modular_int.Z2.to_int s.x_4 } *)
      )

    (*
      IMPORTANT NOTE:
        Corner orientations are not correct under symmetries. However, no
        symmetry *only* orients the corner cubies. In fact, only permutations
        matter for comparisons of cube symmetries.

      With this note in mind, I can explain how we find the products and inverses
      of permutations. Since permutations don't commute, it's not as simple as
      inverting and multiplying the generators. Instead, I convert the symmetry
      to a move on the cubies, multiply the moves, and find the symmetry that
      gives the equivalent move.

      However, since orientations don't work with the natural representation of
      moves, I must ignore the orientation. This is okay because any symmetry
      that moves the cubies appropritately would also orient them appropriately.
    *)
    let mult (s1 : t) (s2 : t) : t =
      (* Symmetries don't commute, so I'll have to convert to moves and compare moves *)
      let m = Move.(to_move s1 * to_move s2) in
      List.find all ~f:(fun a -> Move.equal_without_orientation (to_move a) m)
      |> function
        | Some s -> s
        | None -> failwith "could not find equivalent symmetry for multiplication"

    let inverse (s : t) : t =
      let m = to_move s in
      (** Assume that right inverses are sufficient, and don't need left inverse *)
      List.find all ~f:(fun a -> Move.(equal_without_orientation (m * to_move a) Move.id))
      |> function
        | Some s -> s
        | None -> failwith "could not find inverse symmetry"

    let on_perm (s : t) (p : Perm.t) : Perm.t =
      Move.(to_move s * p * to_move (inverse s))

    let on_fixed_move (s : t) (m : Move.Fixed_move.t) : Move.Fixed_move.t = 
      let open Move in
      let m' = to_move s * Fixed_move.to_move m * to_move (inverse s) in
      List.find Fixed_move.all ~f:(fun a -> equal_without_orientation (Fixed_move.to_move a) m')
      |> function
        | Some m -> m
        | None -> failwith "could not find equivalent move under symmetry"

  end

(*
  The symmetry module is small enough that I can precompute everything
  before the program starts. Since there are only sixteen symmetries,
  this will be very fast.   
*)

(*
  The integer representing the symmetry will be exactly the rank in
  the module S above.   
*)
module I =
  struct
    type t = int [@@deriving sexp]
    let n = S.n
    let to_rank = Fn.id
  end

include I

let of_rank = Fn.id
let next x = if x = n - 1 then None else Some (x + 1)
let zero = 0
let all =
  S.all
  |> List.map ~f:S.to_rank
  |> List.sort ~compare:Int.compare

module Sym_mult_table = Lookup_table.Make2D (I) (I) (I)

let sym_mult_table =
  Sym_mult_table.create all all ~f:(fun x1 x2 -> S.mult (S.of_rank x1) (S.of_rank x2) |> S.to_rank)

let mult = Sym_mult_table.lookup sym_mult_table

module Sym_inverse_table = Lookup_table.Make1D (I) (I)

let inverse =
  all
  |> Sym_inverse_table.create ~f:(fun x -> x |> S.of_rank |> S.inverse |> S.to_rank)
  |> Sym_inverse_table.lookup

(* no memoization possible because there are too many possible permutations *)
let on_perm x =
  x
  |> S.of_rank
  |> S.on_perm

module Sym_move_table = Lookup_table.Make2D (I) (Move.Fixed_move) (Move.Fixed_move)

let on_fixed_move =
  Sym_move_table.create all Move.Fixed_move.all ~f:(fun x m -> let s = S.of_rank x in S.on_fixed_move s m)
  |> Sym_move_table.lookup

let random () = Random.int n
