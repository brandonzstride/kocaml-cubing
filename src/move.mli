(*
  File: move.mli
  Module purpose: represents faceturns on the Rubik's cube, i.e. valid moves.
  Status: complete.

  Detailed description:
    This module describes some move on the cube. These moves might be
    turns of the faces or compositions of faceturns. Arbitrary moves
    are supported by the type as functions from cubies to cubies with
    orientation, but they are not the intended purpose of this module.
    See the `Perm` module for such a purpose.

    A move uses the "is replaced by" notation: if a move is called f, then
    f(URF) = (UFL, 1) means that the URF cubie position on the cube will get
    replaced by the cubie that was in the UFL position, and it will gain
    orientation 1.

    There are two submodules holding the fixed moves. These are All_fixed_move,
    which is all the moves and their multiples that generate the Rubik's cube group,
    and G1_fixed_move, which is all the moves and their multiples that generate the
    G1 subgroup of the Rubik's cube group. These are split so that 
  
  Dependencies:
    Cubie -- moves directly permute the cubies
    Modular_int -- powers of up to four faceturns make up a move
*)

module T :
  sig
    type t = Cubie.t -> Cubie.With_orientation.t
  end

type t = T.t

val id : t
(** [id] is the identity move. It does not permute or orient any cubies. *)

val equal : t -> t -> bool
(** [equal a b] is true if and only if [a] and [b] permute and orient the cubies
    in the exact same way.
    
    Note: since the domain and range are finite, comparison of functions is well-defined. *)

val equal_without_orientation : t -> t -> bool
(** [equal_without_orientation a b] is true if and only if [a] and [b] permute the
    cubies in the exact same way, but they may orient the cubies differently. *)

val ( * ) : t -> t -> t
(** [a * b] composes the moves [a] and [b], where [a] (the left operand) is applied
    first.
    
    Viewed as functions, `(f * g)(x) ~= g(f(x))`.

    It's not typical to compose permutations this way, but it's noted in the "permutation" Wikipedia
    page that this is sometimes done.
    *)

module type Generator =
  sig
    type t [@@deriving enumerate, sexp, compare]
    val to_move : t -> T.t
    (** [to_move gen] gets the move from the generator [gen]. *)

    val to_rank : t -> int
    (** [to_rank gen] sends [gen] to a unique integer, where there is no other
        generator [gen'] not equal to [gen] such that [to_rank gen = to_rank gen']. *)
  end

(* These moves generate the whole cube *)
module Generator : Generator (* It'd be nice to expose the generators *)
(* These generate the G1 subgroup of the cube *)
module G1_generator : Generator

(* The Fixed moves are moves that are generated by exactly one generator *)
(* e.g. the F3 move is three turns of the F face. This is in G but not in G1 *)
module Fixed :
  sig
    (* This is the super type. All S.t can convert to and from it *)
    (* TODO: consider giving this full implementation so users aren't using G below *)
    module Super :
      sig
        type t
        (** [t] is the "super type" for all fixed moves. All other fixed moves can be
            cast up and down to this [t]. *)
      end

    module type S =
      sig
        module Generator : Generator
        (** Fixed moves are generator by some [Generator]. Fixed moves are
            always some integer power of one generator. They are not ever
            combinations of more than one generator. *)

        type t [@@deriving sexp, compare]

        val of_gen : Generator.t -> t
        (** [of_gen gen] gets the fixed move by [gen] to the power of 1. *)

        val of_generator_and_count : Generator.t -> int -> t
        (** [of_generator_and_count gen count] gets the fixed move by [gen]
            to the power of [count]. *)

        val to_generator_and_count : t -> (Generator.t * int)
        (** [to_generator_and_count m] breaks the fixed move [m] down to some
            generator [gen] and the power [count], such that [gen] to the power
            of [count] is equal to [m]. *)

        val all : t list
        (** [all] is a list of all non-identity moves. *)

        val n : int
        (** [n] is the number of non-identity moves. *)

        val to_rank : t -> int (* not defined on identity moves *)
        (** [to_rank m] sends [m] to a unique integer between 0 and [n].
            
            It is not defined on non-identity moves. *)

        val to_move : t -> T.t
        (** [to_move m] sends [m] to a [Move.t]. *)

        val to_super_t : t -> Super.t
        (** [to_super_t m] casts [m] up to the super type [Super.t]. No info is lost in this cast. *)

        val of_super_t : Super.t -> t
        (** [of_super_t s] casts [s] down to this type [t]. No info is lost in this cast. *)

        val random_list : int -> t list
        (** [random_list k] gets a list of length [m] of random moves.
            
            TODO: exchange this for quickcheck. *)
      end

    module G : S with type t = Super.t and type Generator.t = Generator.t
    (** [module G] holds the fixed moves on the whole Rubik's cube group G. These moves are the super
        type because G is the whole group. *)

    module G1 : S with type Generator.t = G1_generator.t
    (** [module G1] is just the fixed moves on the subgroup G1: the cubes with zero orientation and
        all UD slice edges are in the UD slice. *)
  end